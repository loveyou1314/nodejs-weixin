{"./":{"url":"./","title":"前言","keywords":"","body":"Nodejs 开发微信公众号 本小书通过观看 scoot 视频课程《Node.js7天开发微信公众号》，经过学习并结合感受写下的，希望对正在学习这块知识的你能有所帮助。如果你也收益多多，请 --> star 目标 [x] 交互流程 [x] Nodejs 使用技巧 [x] 架构项目方式 [x] Koa 框架使用 [x] ES2015 新特性 实现功能 [x] 获取用户地理位置信息 [x] js sdk 的接入 [x] 菜单功能 [x] 文字回复 [x] 扫二维码、拍照和相册等 [x] 查询：文字和语音 设计技术栈及技术点 js sdk，公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk 授权地址等； yield，ES6 一些特性； koa，web 框架，用来处理服务器之间的应用初始化、接口调用及数据响应； bluebird，尽管 Promise 在高版本 nodejs 里已经提供，但还是引用 bluebird 处理和封装异步请求； request，网络请求，对原生 http request 的封装； ejs，微信的数据包装方式是 xml，借助 ejs 模板库，把数据作为变量替换到 xml 字符中； lodash，工具方法集，比如 heredoc 是一个黑科技，把函数体里面的多行注释作为字符串提取出来主要用来降低拼接字符串的成本; raw-body，用来获取一个 http 请求返回的可读流的内容实体； sha1，加密哈希算法库； xml2js，微信服务器返回的数据依然是 xml 格式，没发直接在 js 函数中使用，借助 xml2js 模块把 xml 数据解析为 js 对象，方便我们使用； 注意点 配置接入流程； 加密认证环节； access_token（凭据）的获取； 需具备 javascript 基础； 利用 Nodejs 开发一些网页或爬虫工具，来对 Nodejs API 和它的技术特点有一些基本的认知； 有一些其他的后端语言经验，无论是PHP/Java/Ruby 均可，主要整明白网络 http 请求从开始到结束中间所经过的环节； 文档和示例地址 github 地址 欢迎评论 你可以 下一篇：关于微信 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"weixin.html":{"url":"weixin.html","title":"关于微信","keywords":"","body":"关于微信号一些说明（文档可能不是最新的） 微信号分类 订阅号，适合于个人、小团队，用于信息传播，帮助管理用户以及和用户互动，比如撰写文章、咨询传播、消息定制等； 服务号，适合于企业和组织，提供更强大的业务服务与用户管理能力，比如支付、智能接口等； 企业号，适合于企业或组织，提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接； 举个适用于学校、学院、班级的例子 分类 说明 订阅号 管理一个班级、一个学院的信息订阅，通知和互动 服务号 管理全学校的打印店等，可以直接支付送货上门，及时推送一些特价活动 企业号 管理全学校所有学院、团委、学生处各部门人员考勤、活动等 订阅号支持的常用接口 会话界面自定义菜单； 多客服接口； 获取用户地理位置； 高级群发接口； 用户分组； 9大接口 语音识别，即语音转文本； 客服接口，发过的消息 24 小时内回复消息； OAuth 2.0 网页授权，通过授权接口，请求用户授权，获取更多用户信息； 生成带参数的二维码，用户扫描关注公众号后根据参数分析各二维码的效果，从而可以实现更多分析结果； 获取用户地理位置； 获取用户信息； 获取关注者列表信息； 用户分组接口，通过分组接口，可以在后台为用户移动、创建、修改分组； 上传、下载多媒体文件； 订阅号和服务号不同 出现位置不同； 订阅号 1篇/天，服务号 4篇/月； 订阅号没有 9大接口和支付功能； 是否认证 认证，得需要有一个开户过的企业（也就是以公司名义），如果是服务号建议认证一下。订阅号认证账号别人可以直接在添加好友里搜索关键词就能找到你。 注意事项 微信公众号接口只支持 80 端口； 微信后台配置的 URL 是唯一能接收到消息和事件的入口，公众号所有操作都是基于这个 URL 进行交互的； 调用所有微信接口时几乎全部使用 https 协议； 用户向公众号发消息时，会传过来 openID，这个 openID 是用户微信号加密后的值，每个用户在每个公众号中 openID 是唯一的； 在开发阶段，要时刻留意报错信息，比如全局返回码，这个特别特别特别地重要，开发出了问题需要手动解决； 和微信服务器交互时，需要满足各个接口的规范限制、调用频率限制、模板消息、用户数据等敏感信息的使用规范； 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：Nodejs 开发微信公众号 下一篇：本地访问和外网访问 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"local_internet.html":{"url":"local_internet.html","title":"本地访问和外网访问","keywords":"","body":"本地访问和外网访问 作为一个 Web 开发者，我们有时候会需要临时地将一个本地的 Web 网站部署到外网，以供他人访问、测试、调试等。你可以 购买域名和服务器 内网穿透 购买域名和服务器 找到一台运行于外网的 Web 服务器； 服务器上有网站所需要的环境，否则自行搭建； 将网站部署到服务器上； 调试结束后，再将网站从服务器上删除； 对应微信服务器实现流程【微信 - 微信的服务器 - 你的域名的服务器】； 如果是一个浏览网站，这么个流程一点儿问题都没有，但是现在的场景临时项目，只是访问、调试等，如此复杂步骤，实非所愿，耗费太多精力在部署环境上，累觉不爱。再看看另一种方式吧。 内网穿透 拿 ngrok 举例，类似软件会很多。你会发现：有了 ngrok 之后，世界是如此美好。 ngrok ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。 反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如 Web 服务器）上获取资源，然后再将这些资源返回给客户端。也就是说客户端只知道代理的IP地址，不知道代理服务器后面的服务器集群的存在。比如 CDN。 顺便再说下前向代理，它是代理客户端的一种。客户端借由前向代理可以间接访问很多不同互联网服务器（集群）的资源，服务端（如Web服务器）只知道代理的 IP 地址，不知道代理客户端的 IP 地址。 实现流程 微信 - 微信的服务器 - 内网穿透的域名的服务器 - 内网穿透工具通道 - 本地代理服务 具体实现 1.本地起个服务 python -m SimpleHTTPServer 1989 本地访问 http://localhost:1989，此刻也就限于你自己访问。 2.ngrok（花生壳、localtunnel）等工具实现 ./ngrok http 1989 3.外网查看 此刻，任何人访问 https://1922e6ad.ngrok.io，都可以看到你本地 http://localhost:1989 所启服务的内容了。 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：关于微信 下一篇：小试编码 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"code.html":{"url":"code.html","title":"小试编码","keywords":"","body":"小试编码 版本一，测通公众号 配置测试公众号 1.进入微信官方文档（公众号）; 2.接口测试号申请，微信公众号的注册有一定门槛，需要占用太多的开发时间，这与我们初衷相违背。可以用测试账号，我们的目的是为了尝试编程，要明白真正要关注的点。 3.测试账号管理 Token- ruizhengyunpr840690384 验证公众号 交互：微信 -> token、timestamp、nonce 字典排序 -> 拼接为字符串再 sha1 加密 -> (result === signature) -> return echostr 将 token、timestamp、nonce 三个参数进行字典排序； 将三个参数字符串拼接成一个字符串进行 sha1 加密； 将加密后的字符串与 signature 对比，如果相同，表示这个请求来源于微信，直接原样返回 echostr 参数内容，接入验证就成功了； 代码实现 1.启动项文件 // app-1.js /** * @创建码农: pr * @创建日期: 2019-12-26 19:47:02 * @最近更新: pr * @更新时间: 2019-12-26 19:47:02 * @文件描述: 启动项文件 */ const Koa = require('koa'); const sha1 = require('sha1'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384' } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(function*(next) { console.log('query', this.query); const token = config.wechat.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { this.body = echostr + ''; } else { this.body = '不是来源于微信'; } }); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.启动本地服务 node --harmony app-1.js 3.ngrok 启动代理本地服务 ./ngrok http 1989 4.拷贝 ngrok 产生的 https 地址到微信公众号 > 接口配置信息 > URL 中，然后点击 提交，结果如下 5.查看本地服务控制台 版本二，抽取公众号参数的校验中间件 版本一，我们实现了微信公众号验证成功，本着专业人做专业事，单一文件实现单一功能的原则，可以将中间件抽离处理独立成为一个文件，然后启动项文件引入传参再调用。 代码实现 1.启动项文件 // app-2.js /** * @创建码农: pr * @创建日期: 2019-12-27 19:47:02 * @最近更新: pr * @更新时间: 2019-12-27 19:47:02 * @文件描述: 启动项文件，版本二 */ const Koa = require('koa'); const weChatMiddleWare = require('./app-2/weChat'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384' } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.中间件 // app-2/weChat.js /** * @创建码农: pr * @创建日期: 2019-12-27 19:47:02 * @最近更新: pr * @更新时间: 2019-12-27 19:47:02 * @文件描述: 公众号校验中间件 */ const sha1 = require('sha1'); // 中间件 module.exports = function(opts) { return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { console.log('来源于微信'); this.body = echostr + ''; } else { console.log('不是来源于微信'); this.body = '不是来源于微信'; } }; }; 3.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址，然后是否公众号是否验证成功。这个版本只是改写，并未产生新的功能代码，所以没什么难题。 版本三，解决 access_token（凭证）失效问题 access_token 特性 access_token 每2小时（7200秒）自动失效，需要重新获取； 只要更新了 access_token，之前的 access_token 就没用了； 设计方案 系统每隔 2 小时启动去刷新一次 access_token，这样无论什么时候调用接口，都是最新的； 为了方便频繁调用，所以的把更新 access_token 存储在一个唯一的地方（一定不要存内存）； 代码实现 1.启动项，这块要建个 /app-3/config/access-token.txt // app-3.js /** * @创建码农: pr * @创建日期: 2019-12-28 19:47:02 * @最近更新: pr * @更新时间: 2019-12-28 19:47:02 * @文件描述: 启动项文件，版本三 */ const Koa = require('koa'); const path = require('path'); const util = require('./app-3/util'); const weChatMiddleWare = require('./app-3/weChat'); const wechat_file = path.join(__dirname, './app-3/config/access-token.txt'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384', getAccessToken: () => { return util.readFileAsync(wechat_file); }, saveAccessToken: data => { data = JSON.stringify(data); return util.writeFileAsync(wechat_file, data); } } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.中间件 // app-3/util.js /** * @创建码农: pr * @创建日期: 2019-12-28 19:47:02 * @最近更新: pr * @更新时间: 2019-12-28 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const sha1 = require('sha1'); const Promise = require('bluebird'); const request = Promise.promisify(require('request')); // 参数定义 const prefix = 'https://api.weixin.qq.com/cgi-bin/'; const api = { accessToken: `${prefix}token?grant_type=client_credential` }; // 判断 access_token 是否过期 function AccessTokenInfo(opts) { const that = this; this.appID = opts.appID; this.appSecret = opts.appSecret; this.getAccessToken = opts.getAccessToken; this.saveAccessToken = opts.saveAccessToken; that .getAccessToken() .then(function(data) { try { data = JSON.parse(data); } catch (e) { // 不合法就重新更新 access_token return that.updateAccessToken(); } if (that.isValidAccessToken(data)) { // 判断是否有效 return Promise.resolve(data); } else { // 不合法就重新更新 access_token return that.updateAccessToken(); } }).then(data => { // 取到合法 access_token that.access_token = data.access_token; that.expires_in = data.expires_in; that.saveAccessToken(data); }); } // 验证 access_token 是否有效 AccessTokenInfo.prototype.isValidAccessToken = function(data) { if (!data || !data.access_token || !data.expires_in) { return false; } const now = new Date().getTime(); if (now { request({ url, json: true }).then(res => { const data = res.body; console.log('data', data); const now = new Date().getTime(); // 缩短 20 秒（算上网络请求时间） const expires_in = now + (data.expires_in - 20) * 1000; data.expires_in = expires_in; resolve(data); }); }); }; // 中间件 module.exports = function(opts) { const accessTokenInfo = new AccessTokenInfo(opts); return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { console.log('来源于微信'); this.body = echostr + ''; } else { console.log('不是来源于微信'); this.body = '不是来源于微信'; } }; }; 3.编写工具库 /** * @创建码农: 芮正云 16396@etransfar.com * @创建日期: 2019-12-28 16:58:04 * @最近更新: 芮正云 16396@etransfar.com * @更新时间: 2019-12-28 16:58:04 * @文件描述: 工具库 */ const fs = require('fs'); const Promise = require('bluebird'); // access_token 读操作 exports.readFileAsync = (fpath, encoding) => { return new Promise((resolve, reject) => { fs.readFile(fpath, encoding, function(err, content) { if (err) { reject(err); } else { resolve(content); } }); }); }; // access_token 写操作 exports.writeFileAsync = (fpath, content) => { return new Promise((resolve, reject) => { fs.writeFile(fpath, content, function(err, content) { if (err) { reject(err); } else { resolve(); } }); }); }; 4.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址 5.你会发现 /app-3/config/access-token.txt 文件生成 access_token 信息内容 版本四，实现自动回复 这次我们要实现，关注公众号后自动回复订阅成功的消息。 实现流程 处理 POST 类型的控制逻辑，接收这个 XML 数据包； 解析 XML 数据包； 拼写需要定义的消息； 包装成 XML 格式； 5 秒内返回回去； 测试号二维码 关注公众号后 关注公众号后 ToUserName，接收方账号； FromUserName，发送方账号，即 openid； CreateTime，发送消息时间； MsgType，消息类型。 代码实现 1.启动项 // app-4.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 启动项文件，版本四 */ const Koa = require('koa'); const path = require('path'); const fileAsync = require('./app-4/util/fileAsync'); const weChatMiddleWare = require('./app-4/middleWare/weChat'); const wechat_file = path.join(__dirname, './app-4/config/access-token.txt'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384', getAccessToken: () => { // 读取文件 return fileAsync.readFileAsync(wechat_file); }, saveAccessToken: data => { // 写入文件 return fileAsync.writeFileAsync(wechat_file, JSON.stringify(data)); } } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.编写中间件 // app-4/middleWare/weChat.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const sha1 = require('sha1'); const rawBody = require('raw-body'); const fileAsync = require('../util/fileAsync'); const AccessTokenInfo = require('../util/AccessTokenInfo'); // 中间件 module.exports = function(opts) { const accessTokenInfo = new AccessTokenInfo(opts); return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); /** * GET 验证开发者身份 * POST */ if (sha !== signature) { this.body = '❌'; return false; } if (this.method === 'GET') { this.body = echostr + ''; } else if (this.method === 'POST') { // 依赖包 raw-body 可以把 this 上的 request 对象（http 模块中的 request 对象），拼写它的数据，最终拿到一个 buffer 的 XML const data = yield rawBody(this.req, { length: this.length, limit: '1mb', encoding: this.charset }); const content = yield fileAsync.parseXMLAsync(data); const message = fileAsync.formatMessage(content.xml); if (message.MsgType === 'event') { if (message.Event === 'subscribe') { const now = new Date().getTime(); this.status = 200; this.type = 'application/xml'; // 文本模板，后面可以把这块业务抽离处理 this.body = ` ${now} 1234567890123456 `; console.log('message', this.body); return; } } console.log('message', message); } }; }; 3.编写工具库 // app-4/uitl/fileAsync.js /** * @创建码农: pr * @创建日期: 2019-12-29 16:58:04 * @最近更新: pr * @更新时间: 2019-12-29 16:58:04 * @文件描述: 工具库 */ const fs = require('fs'); const Promise = require('bluebird'); const xml2js = require('xml2js'); // access_token 读操作 exports.readFileAsync = (fpath, encoding) => { return new Promise((resolve, reject) => { fs.readFile(fpath, encoding, function(err, content) { if (err) { reject(err); } else { resolve(content); } }); }); }; // access_token 写操作 exports.writeFileAsync = (fpath, content) => { return new Promise((resolve, reject) => { fs.writeFile(fpath, content, function(err, content) { if (err) { reject(err); } else { resolve(); } }); }); }; // 格式化 xml 消息 function formatMessage(data) { const message = {}; if (typeof data === 'object') { const keys = Object.keys(data); for (let i = 0; i // app-4/util/AccessTokenInfo.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const Promise = require('bluebird'); const request = Promise.promisify(require('request')); // 参数定义 const prefix = 'https://api.weixin.qq.com/cgi-bin/'; const api = { accessToken: `${prefix}token?grant_type=client_credential` }; // 判断 access_token 是否过期 function AccessTokenInfo(opts) { const that = this; this.appID = opts.appID; this.appSecret = opts.appSecret; this.getAccessToken = opts.getAccessToken; this.saveAccessToken = opts.saveAccessToken; that.getAccessToken().then(function(data) { try { data = JSON.parse(data); } catch (e) { // 不合法就重新更新 access_token return that.updateAccessToken(); } if (that.isValidAccessToken(data)) { //判断是否有效 // Promise.resolve(data); // 取到合法 access_token that.access_token = data.access_token; that.expires_in = data.expires_in; that.saveAccessToken(data); } else { // 不合法就重新更新 access_token return that.updateAccessToken(); } }); // .then(function(data) { // // 取到合法 access_token // that.access_token = data.access_token; // that.expires_in = data.expires_in; // that.saveAccessToken(data); // }); } // 验证 access_token 是否有效 AccessTokenInfo.prototype.isValidAccessToken = function(data) { if (!data || !data.access_token || !data.expires_in) { return false; } const now = new Date().getTime(); if (now { request({ url, json: true }).then(res => { const data = res.body; const now = new Date().getTime(); // 缩短 20 秒（算上网络请求时间） const expires_in = now + (data.expires_in - 20) * 1000; data.expires_in = expires_in; resolve(data); }); }); }; module.exports = AccessTokenInfo; 5.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址 6.扫描关注公众号 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：本地访问和外网访问 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"message_encapsulation.html":{"url":"message_encapsulation.html","title":"消息封装","keywords":"","body":"消息封装 在上节，我们稍稍尝到了点甜头（订阅后自动回复），本章将实现更多有用的消息功能，如文本、图文、语音和音乐等。 1.启动项文件 [x] 抽离出公共配置文件 app-5/config/default.config.js； [x] 新增公共方法库-消息模块 app-5/util/message； [x] weChatMiddleWare 中间件添加第二个参数，即消息回复方法； /** * @创建码农: pr * @创建日期: 2019-12-30 9:20:27 * @最近更新: pr * @更新时间: 2019-12-30 9:20:27 * @文件描述: 启动项文件 */ const Koa = require('koa'); const weChatMiddleWare = require('./app-5/middleWare/weChat'); const config = require('./app-5/config/default.config'); const message = require('./app-5/util/message'); const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat, message.reply)); app.listen(config.PORT); console.log(`正在监听：${config.PORT}`); 2.公共配置文件 app-5/config/default.config.js /** * @创建码农: pr * @创建日期: 2019-12-30 13:14:03 * @最近更新: pr * @更新时间: 2019-12-30 13:14:03 * @文件描述: 公共配置文件 */ const path = require('path'); const util = require('../util'); const wechat_file = path.join(__dirname, './access-token.txt'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384', getAccessToken: () => { // 读取文件 return util.readFileAsync(wechat_file); }, saveAccessToken: data => { // 写入文件 return util.writeFileAsync(wechat_file, JSON.stringify(data)); } }, PORT: 1989 }; module.exports = config; 3.公共方法库-消息模块 app-5/util/message console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}